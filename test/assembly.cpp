// This file is used to compare the assembly generated by the bit_field library to the assembly generated by manually
// performing the bit shifting in a very straightforward way. Several bit_field_config options are tested. Each config
// is placed in its own namespace, and within each of those namespaces there are two other namespaces -- using_bf and
// using_manual. Within each of those namespaces there are get and set functions for each of the three fields, address,
// channel, and direction. In total, this makes thirty pairs of functions which can be compared to each other to ensure
// that the assembly generated by the bit_field library is equivalent to the assembly generated by doing things
// manually as efficiently as possible.
//
// Here is the full list of generated function pairs which should be compared:
//
//           default_config::using_bf::get_address   /       default_config::using_manual::get_address
//           default_config::using_bf::set_address   /       default_config::using_manual::set_address
//           default_config::using_bf::get_channel   /       default_config::using_manual::get_channel
//           default_config::using_bf::set_channel   /       default_config::using_manual::set_channel
//           default_config::using_bf::get_direction /       default_config::using_manual::get_direction
//           default_config::using_bf::set_direction /       default_config::using_manual::set_direction
//                 no_shift::using_bf::get_address   /             no_shift::using_manual::get_address
//                 no_shift::using_bf::set_address   /             no_shift::using_manual::set_address
//                 no_shift::using_bf::get_channel   /             no_shift::using_manual::get_channel
//                 no_shift::using_bf::set_channel   /             no_shift::using_manual::set_channel
//                 no_shift::using_bf::get_direction /             no_shift::using_manual::get_direction
//                 no_shift::using_bf::set_direction /             no_shift::using_manual::set_direction
//       unchecked_strategy::using_bf::get_address   /   unchecked_strategy::using_manual::get_address
//       unchecked_strategy::using_bf::set_address   /   unchecked_strategy::using_manual::set_address
//       unchecked_strategy::using_bf::get_channel   /   unchecked_strategy::using_manual::get_channel
//       unchecked_strategy::using_bf::set_channel   /   unchecked_strategy::using_manual::set_channel
//       unchecked_strategy::using_bf::get_direction /   unchecked_strategy::using_manual::get_direction
//       unchecked_strategy::using_bf::set_direction /   unchecked_strategy::using_manual::set_direction
//     return_bool_strategy::using_bf::get_address   / return_bool_strategy::using_manual::get_address
//     return_bool_strategy::using_bf::set_address   / return_bool_strategy::using_manual::set_address
//     return_bool_strategy::using_bf::get_channel   / return_bool_strategy::using_manual::get_channel
//     return_bool_strategy::using_bf::set_channel   / return_bool_strategy::using_manual::set_channel
//     return_bool_strategy::using_bf::get_direction / return_bool_strategy::using_manual::get_direction
//     return_bool_strategy::using_bf::set_direction / return_bool_strategy::using_manual::set_direction
//       exception_strategy::using_bf::get_address   /   exception_strategy::using_manual::get_address
//       exception_strategy::using_bf::set_address   /   exception_strategy::using_manual::set_address
//       exception_strategy::using_bf::get_channel   /   exception_strategy::using_manual::get_channel
//       exception_strategy::using_bf::set_channel   /   exception_strategy::using_manual::set_channel
//       exception_strategy::using_bf::get_direction /   exception_strategy::using_manual::get_direction
//       exception_strategy::using_bf::set_direction /   exception_strategy::using_manual::set_direction
//
// The assembly-level comparison can likely be done automatically with some objdump magic, but presently it is manually
// verified by pasting the contents of this file into godbolt.org with the appropriate #include.

// Constants required to do things manually.
#define ADDRESS_MASK        0b00011111
#define ADDRESS_OFFSET      0
#define CHANNEL_MASK        0b01100000
#define CHANNEL_OFFSET      5
#define CHANNEL_ENUM_MASK   0b11
#define DIRECTION_MASK      0b10000000
#define DIRECTION_OFFSET    7
#define DIRECTION_ENUM_MASK 0b1

// Templated bitfield definition. Very weird, but it works and allows use to use the same class definition with
// different bit field configurations for testing, as long as the enum values are shifted.
template <bf::bit_field_config<void> TCfg>
struct m_sequence_control_template : bf::bit_field_builder<m_sequence_control_template<TCfg>, std::uint8_t, TCfg> {
    enum class communication_channel {
        process   = 0,
        page      = 1,
        diagnosis = 2,
        isdu      = 3
    };

    enum class transmission_direction {
        write = 0,
        read  = 1
    };

    BIT_FIELD_DEP(m_sequence_control_template::, address,   5, bf::bit_field_config<std::uint8_t>{});
    BIT_FIELD_DEP(m_sequence_control_template::, channel,   2, bf::bit_field_config<communication_channel>{});
    BIT_FIELD_DEP(m_sequence_control_template::, direction, 1, bf::bit_field_config<transmission_direction>{});
};

// Code generating macro, since we can use the same bit field functions in all cases.
#define IMPLEMENT_BIT_FIELD_FUNCTIONS                                                           \
    namespace using_bf {                                                                        \
                                                                                                \
    std::uint8_t get_address(std::uint8_t input) {                                              \
        return m_sequence_control::address::get(input);                                         \
    }                                                                                           \
                                                                                                \
    auto set_address(std::uint8_t& input, std::uint8_t value) {                                 \
        return m_sequence_control::address::set(input, value);                                  \
    }                                                                                           \
                                                                                                \
    m_sequence_control::communication_channel get_channel(std::uint8_t input) {                 \
        return m_sequence_control::channel::get(input);                                         \
    }                                                                                           \
                                                                                                \
    auto set_channel(std::uint8_t& input, m_sequence_control::communication_channel value) {    \
        return m_sequence_control::channel::set(input, value);                                  \
    }                                                                                           \
                                                                                                \
    m_sequence_control::transmission_direction get_direction(std::uint8_t input) {              \
        return m_sequence_control::direction::get(input);                                       \
    }                                                                                           \
                                                                                                \
    auto set_direction(std::uint8_t& input, m_sequence_control::transmission_direction value) { \
        return m_sequence_control::direction::set(input, value);                                \
    }                                                                                           \
                                                                                                \
    } 

namespace default_config {

using m_sequence_control = m_sequence_control_template<bf::bit_field_config{}>;

IMPLEMENT_BIT_FIELD_FUNCTIONS

namespace using_manual {

std::uint8_t get_address(std::uint8_t input) {
    return input & ADDRESS_MASK;
}

void set_address(std::uint8_t& input, std::uint8_t value) {
    input = static_cast<std::uint8_t>((input & ~ADDRESS_MASK) | ((value & ADDRESS_MASK) << ADDRESS_OFFSET));
}

m_sequence_control::communication_channel get_channel(std::uint8_t input) {
    return static_cast<m_sequence_control::communication_channel>((input & CHANNEL_MASK) >> CHANNEL_OFFSET);
}

void set_channel(std::uint8_t& input, m_sequence_control::communication_channel value) {
    input = static_cast<std::uint8_t>((input & ~CHANNEL_MASK) | ((static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) & CHANNEL_ENUM_MASK) << CHANNEL_OFFSET));
}

m_sequence_control::transmission_direction get_direction(std::uint8_t input) {
    return static_cast<m_sequence_control::transmission_direction>((input & DIRECTION_MASK) >> DIRECTION_OFFSET);
}

void set_direction(std::uint8_t& input, m_sequence_control::transmission_direction value) {
    input = static_cast<std::uint8_t>((input & ~DIRECTION_MASK) | ((static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) & DIRECTION_ENUM_MASK) << DIRECTION_OFFSET));
}

} // End namespace using_manual.

} // End namespace default_config.

namespace no_shift {

// Need a special definition here since the enum values change.
struct m_sequence_control : bf::bit_field_builder<m_sequence_control, std::uint8_t, bf::bit_field_config{ .offset = bf::no_shift }> {
    static constexpr int communication_channel_shift = 5;
    enum class communication_channel : std::uint8_t {
        process   = (0 << communication_channel_shift),
        page      = (1 << communication_channel_shift),
        diagnosis = (2 << communication_channel_shift),
        isdu      = (3 << communication_channel_shift)
    };

    static constexpr int transmission_direction_shift = 7;
    enum class transmission_direction : std::uint8_t {
        write = (0 << transmission_direction_shift),
        read  = (1 << transmission_direction_shift)
    };

    BIT_FIELD(address,   5, bf::bit_field_config<std::uint8_t>{});
    BIT_FIELD(channel,   2, bf::bit_field_config<communication_channel>{});
    BIT_FIELD(direction, 1, bf::bit_field_config<transmission_direction>{});
};

IMPLEMENT_BIT_FIELD_FUNCTIONS

namespace using_manual {

std::uint8_t get_address(std::uint8_t input) {
    return input & ADDRESS_MASK;
}

void set_address(std::uint8_t& input, std::uint8_t value) {
    input = static_cast<std::uint8_t>((input & ~ADDRESS_MASK) | (value & ADDRESS_MASK));
}

m_sequence_control::communication_channel get_channel(std::uint8_t input) {
    return static_cast<m_sequence_control::communication_channel>(input & CHANNEL_MASK);
}

void set_channel(std::uint8_t& input, m_sequence_control::communication_channel value) {
    input = static_cast<std::uint8_t>((input & ~CHANNEL_MASK) | ((static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) & CHANNEL_MASK)));
}

m_sequence_control::transmission_direction get_direction(std::uint8_t input) {
    return static_cast<m_sequence_control::transmission_direction>(input & DIRECTION_MASK);
}

void set_direction(std::uint8_t& input, m_sequence_control::transmission_direction value) {
    input = static_cast<std::uint8_t>((input & ~DIRECTION_MASK) | ((static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) & DIRECTION_MASK)));
}

} // End namespace using_manual.

} // End namespace no_shift.

namespace unchecked_strategy {

using m_sequence_control = m_sequence_control_template<bf::bit_field_config{ .strategy = bf::bit_field_assignment_strategy::unchecked }>;

IMPLEMENT_BIT_FIELD_FUNCTIONS

namespace using_manual {

std::uint8_t get_address(std::uint8_t input) {
    return input & ADDRESS_MASK;
}

void set_address(std::uint8_t& input, std::uint8_t value) {
    input = static_cast<std::uint8_t>((input & ~ADDRESS_MASK) | (value << ADDRESS_OFFSET));
}

m_sequence_control::communication_channel get_channel(std::uint8_t input) {
    return static_cast<m_sequence_control::communication_channel>((input & CHANNEL_MASK) >> CHANNEL_OFFSET);
}

void set_channel(std::uint8_t& input, m_sequence_control::communication_channel value) {
    input = static_cast<std::uint8_t>((input & ~CHANNEL_MASK) | (static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) << CHANNEL_OFFSET));
}

m_sequence_control::transmission_direction get_direction(std::uint8_t input) {
    return static_cast<m_sequence_control::transmission_direction>((input & DIRECTION_MASK) >> DIRECTION_OFFSET);
}

void set_direction(std::uint8_t& input, m_sequence_control::transmission_direction value) {
    input = static_cast<std::uint8_t>((input & ~DIRECTION_MASK) | (static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) << DIRECTION_OFFSET));
}

} // End namespace using_manual.

} // End namespace unchecked_strategy.

namespace return_bool_strategy {

using m_sequence_control = m_sequence_control_template<bf::bit_field_config{ .strategy = bf::bit_field_assignment_strategy::return_bool }>;

IMPLEMENT_BIT_FIELD_FUNCTIONS

namespace using_manual {

std::uint8_t get_address(std::uint8_t input) {
    return input & ADDRESS_MASK;
}

bool set_address(std::uint8_t& input, std::uint8_t value) {
    if (value & ~ADDRESS_MASK) {
        return false;
    } else {
        input = static_cast<std::uint8_t>((input & ~ADDRESS_MASK) | (value << ADDRESS_OFFSET));
        return true;
    }
}

m_sequence_control::communication_channel get_channel(std::uint8_t input) {
    return static_cast<m_sequence_control::communication_channel>((input & CHANNEL_MASK) >> CHANNEL_OFFSET);
}

bool set_channel(std::uint8_t& input, m_sequence_control::communication_channel value) {
    if (static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) & ~CHANNEL_ENUM_MASK) {
        return false;
    } else {
        input = static_cast<std::uint8_t>((input & ~CHANNEL_MASK) | (static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) << CHANNEL_OFFSET));
        return true;
    }
}

m_sequence_control::transmission_direction get_direction(std::uint8_t input) {
    return static_cast<m_sequence_control::transmission_direction>((input & DIRECTION_MASK) >> DIRECTION_OFFSET);
}

bool set_direction(std::uint8_t& input, m_sequence_control::transmission_direction value) {
    if (static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) & ~DIRECTION_ENUM_MASK) {
        return false;
    } else {
        input = static_cast<std::uint8_t>((input & ~DIRECTION_MASK) | (static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) << DIRECTION_OFFSET));
        return true;
    }
}

} // End namespace using_manual.

} // End namespace return_bool_strategy.

namespace exception_strategy {

using m_sequence_control = m_sequence_control_template<bf::bit_field_config{ .strategy = bf::bit_field_assignment_strategy::exception }>;

IMPLEMENT_BIT_FIELD_FUNCTIONS

namespace using_manual {

std::uint8_t get_address(std::uint8_t input) {
    return input & ADDRESS_MASK;
}

void set_address(std::uint8_t& input, std::uint8_t value) {
    if (value & ~ADDRESS_MASK) {
        throw bf::bit_field_error("invalid bits set");
    }

    input = static_cast<std::uint8_t>((input & ~ADDRESS_MASK) | (value << ADDRESS_OFFSET));
}

m_sequence_control::communication_channel get_channel(std::uint8_t input) {
    return static_cast<m_sequence_control::communication_channel>((input & CHANNEL_MASK) >> CHANNEL_OFFSET);
}

void set_channel(std::uint8_t& input, m_sequence_control::communication_channel value) {
    if (static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) & ~CHANNEL_ENUM_MASK) {
        throw bf::bit_field_error("invalid bits set");
    }

    input = static_cast<std::uint8_t>((input & ~CHANNEL_MASK) | (static_cast<std::underlying_type_t<m_sequence_control::communication_channel>>(value) << CHANNEL_OFFSET));
}

m_sequence_control::transmission_direction get_direction(std::uint8_t input) {
    return static_cast<m_sequence_control::transmission_direction>((input & DIRECTION_MASK) >> DIRECTION_OFFSET);
}

void set_direction(std::uint8_t& input, m_sequence_control::transmission_direction value) {
    if (static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) & ~DIRECTION_ENUM_MASK) {
        throw bf::bit_field_error("invalid bits set");
    }

    input = static_cast<std::uint8_t>((input & ~DIRECTION_MASK) | (static_cast<std::underlying_type_t<m_sequence_control::transmission_direction>>(value) << DIRECTION_OFFSET));
}

} // End namespace using_manual.

} // End namespace exception_strategy.
